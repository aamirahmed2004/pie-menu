using System;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using Unity.VisualScripting;
using UnityEngine;
using Random = System.Random;

public class TargetManager : MonoBehaviour
{
    [SerializeField] private GameObject targetWithLabel;
    private float targetScale = 1.0f;
    private int numTargets = 24;
    private List<Target> targetList = new();

    // Where we store the list of positions generated by an algorithm to create desktop-like layout. Each vector3 is {x = xPos, y = yPos, z = quadrant (between 1-4)}.
    private List<Vector3> targetPositions = new();       
    
    private Camera mainCamera;
    private Vector3 screenCentre;
    private Vector3 worldCentre;
    private GameObject startTargetObject;

    private float worldWidth, worldHeight;
    private float targetWidth, targetHeight;
    private const float TargetSpacing = 1.5f;
    private string[] appNames = { "TaskFlow Pro", "NoteHaven", "DocuMaster", "QuickNote", "PlanEase", 
                                    "Taskify", "PaperTrail", "MemoGraph", "TimeLine", "FocusBox", "SprintTrack", "ZenDoc", "ProWriter", 
                                    "StudySpace", "QuickOffice", "PrintMaster", "WorkBench", "FileForge", "ClearWrite", "ProDesk", "SnapCraft", 
                                    "PixelCraftr", "IdeaScribe", "SketchBlend", "ColorPulse", "DesignForge", "Artify", "VibeDraw", "VectorPrime", 
                                    "PhotoLab", "SoundCraftr", "ClipStudio", "MindWave", "Animatrix", "LightBurst", "FlowSketch", "MotionDeck", 
                                    "CanvasNova", "ImageForge", "ShapeWave", "CodeForge", "DevPad", "GitHub Pro", "ScriptRunner", "BuildSphere", "CompilerX", 
                                    "CodeFlow", "DebugMaster", "DevSync", "TerminalX", "CloudIDE", "SnapBuild", "CodeSmith", "DevDesk", "AppSync", 
                                    "SourceCraft", "DevSnap", "ProjectPad", "VersionVault", "SyncWrite", "MovieBox", "Streamify", "RadioFusion", 
                                    "MusicMate", "GameSparks", "PlayBox", "CineMate", "SoundStorm", "MovieVault", "AudioFlow", "MediaCraft", "SongLab", 
                                    "StreamX", "ShowLoop", "FlickPlay", "SoundBurst", "GameForge", "ChillBox", "MusicWave", "TuneMaster", "FileMender", "DiskCleaner", "BackupHub", "CleanSweep" };

    public Target startTarget;
    public Target primeTarget;

    public Dictionary<int, Vector2> zoneCentroids = new();

    public Dictionary<int, Vector4> zoneBounds = new();
    
    // Awake() is called before any other GameObject's Start() 
    private void Awake()
    {
        mainCamera = Camera.main;
        mainCamera.orthographicSize = 15.0f / ((float) Screen.width / Screen.height);
        
        screenCentre = new Vector3(Screen.width / 2, Screen.height / 2, 1f);
        worldCentre = mainCamera.ScreenToWorldPoint(screenCentre);

        worldHeight = mainCamera.orthographicSize * 2.0f;
        worldWidth = worldHeight * mainCamera.aspect;
        GetTargetSize();
        GenerateTargetPositions();
        ResetZones();
        // SpawnTargets();      TargetManager no longer spawns targets, it makes the method public so StudyManager can call it instead.
    }
    
    public void Update()
    {
        targetList.RemoveAll(t => t.IsDestroyed());
    }

    private void GetTargetSize()
    {
        var sampleTarget = Instantiate(targetWithLabel, new Vector3(0,0,0), Quaternion.identity);
        sampleTarget.transform.localScale = Vector3.one * targetScale;
        sampleTarget.name = "SampleTarget";
        sampleTarget.transform.parent = mainCamera.transform;

        Canvas.ForceUpdateCanvases();
        var targetSprite = sampleTarget.GetComponentInChildren<SpriteRenderer>();
        var targetText = sampleTarget.GetComponentInChildren<TextMeshPro>();
        targetWidth = targetSprite.sprite.bounds.size.x;
        targetHeight = targetSprite.sprite.bounds.size.y + targetText.bounds.size.y;
        Destroy(sampleTarget);
        Canvas.ForceUpdateCanvases();
    }

    private void GenerateTargetPositions()
    {
        targetPositions.Clear();
        var columns = (int) (worldWidth / (TargetSpacing * targetScale));
        var rows = (int) (worldHeight / (TargetSpacing * targetScale));
        for (var y = (int) -Math.Floor(rows/2.0f); y < (int) Math.Floor(rows/2.0f); y++)
        {
            for (var x = -columns/2; x < columns/2; x++)
            {
                if ((new Vector2(x + targetWidth / 2, y + targetHeight / 2) - Vector2.zero).magnitude <= CircleManager.CircleRadius*1.1)
                    continue;
                var xval = x >= 0;
                var yval = y >= 0;
                var quadrant = 1;
                if (xval && yval)
                {
                    quadrant = 2;
                } 
                else if (!xval && !yval)
                {
                    quadrant = 3;
                }
                else if (xval)
                {
                    quadrant = 4;
                }
                var xPos = x + targetWidth / 2;
                var yPos = y + targetHeight / 2; 
                targetPositions.Add(new Vector3(xPos,yPos,quadrant));
            }
        }
    }
    
    public void SpawnTargets(TrialConditions trialConditions)
    {
        targetScale = trialConditions.width;
        GetTargetSize();
        GenerateTargetPositions();
        int appIndex = 0;
        int targetCount = 0;
        Debug.Log("Amplitude: " + trialConditions.amplitude + ", Ratio: " + trialConditions.width + ", Quadrants: " + trialConditions.quadrants);
        
        // Pick the Target the user is meant to select first, retrieving the remaining allowed positions & the selected position
        var (validPositions, primePosition) = PickTarget(trialConditions.amplitude, trialConditions.quadrants);
        // Structure for recording the positions in each quadrant for centroid + bounding box data
        var zonesPositions = new Dictionary<int, List<Vector3>>();
        // Add the prime target's list first, then add it to the list of positions for its zone so it is factored into
        // the bounding box and centroid determination
        zonesPositions.Add((int) primePosition.z, new List<Vector3>());
        zonesPositions[(int) primePosition.z].Add(primePosition);
        
        var rand = new Random();
        
        // Start at quadrant 4 and go backwards to 1. Makes it easier to add remaining targets to the top left (since on a desktop the top left is often more dense).
        for (int quadrant = trialConditions.quadrants; quadrant >= 1; quadrant--)
        {
            // This may already exist due to selection of the target beforehand
            if (!zonesPositions.ContainsKey(quadrant))
            {
                // Add the list of positions for this quadrant to the dictionary
                zonesPositions.Add(quadrant, new List<Vector3>());   
            }
            // Get positions for each z-value (quadrant)
            List<Vector3> quadrantPositions = validPositions.Where(vector => (int) vector.z == quadrant).ToList();
            int targetCountPerQuadrant = 0;
            while (targetCountPerQuadrant < ((int) numTargets/4) && quadrantPositions.Count > 0) // evenly distribute some targets between 4 quadrants
            {
                if (appIndex >= appNames.Length) appIndex = 0;

                // Treat it like a queue
                Vector3 position = quadrantPositions[0];
                quadrantPositions.RemoveAt(0);
                if (rand.Next(0, 4) == 2)
                {
                    quadrantPositions.Add(position);
                    continue;
                }
                // Add selected position to dictionary
                zonesPositions[quadrant].Add(position);
                SpawnTargetWithLabel(position.x, position.y, appIndex);
                targetCountPerQuadrant++; targetCount++;
                appIndex++;         
            }

            if (quadrant != 1) continue;

            // If target count is not a multiple of 4, there will be some targets left to add. Add them all to the top left quadrant.
            // At this point in the for loop, quadrant = 1 so quadrantPositions contains positions of targets in Q1. 
            while (targetCount < numTargets && quadrantPositions.Count > 0)
            {
                // Repeated code but we can refactor later.
                if (appIndex >= appNames.Length) appIndex = 0;

                Vector3 position = quadrantPositions[0];
                quadrantPositions.RemoveAt(0);
                if (rand.Next(0, 4) == 2)
                {
                    quadrantPositions.Add(position);
                    continue;
                }
                zonesPositions[quadrant].Add(position);
                SpawnTargetWithLabel(position.x, position.y, appIndex);
                targetCount++;
                appIndex++;
            }
        }

        // Calculate the bounding box & centroid for each zone (quadrant)
        foreach (var zonePositions in zonesPositions)
        {
            UpdateZoneBoundsAndCentroids(zonePositions.Key, zonePositions.Value);
        }
    }

    private void UpdateZoneBoundsAndCentroids(int quadrant, List<Vector3> positions)
    {
        // Simple calculation for the centroid (mean position of all targets in quadrant)
        zoneCentroids[quadrant] = new Vector2(
            positions.ConvertAll(vec => vec.x * TargetSpacing * targetScale).Average(),
            positions.ConvertAll(vec => vec.y * TargetSpacing * targetScale).Average()
        );
        // Quadrant bounding box is slightly padded so it doesn't fit as tightly around the targets themselves
        zoneBounds[quadrant] = new Vector4(
            Math.Max(-worldWidth/2,positions.ConvertAll(vec => vec.x * TargetSpacing * targetScale).Min() - targetWidth),
            Math.Min(worldWidth/2, positions.ConvertAll(vec => vec.x * TargetSpacing * targetScale).Max() + targetWidth),
            Math.Max(-worldHeight/2, positions.ConvertAll(vec => vec.y * TargetSpacing * targetScale).Min() - targetHeight),
            Math.Min(worldHeight/2, positions.ConvertAll(vec => vec.y * TargetSpacing * targetScale).Max() + targetHeight)
        );
    }

    public void ResetZones()
    {
        zoneCentroids = new()
        {
            { 1, new Vector2() },
            { 2, new Vector2() },
            { 3, new Vector2() },
            { 4, new Vector2() }
        };
        zoneBounds = new()
        {
            {1, new Vector4()},
            {2, new Vector4()},
            {3, new Vector4()},
            {4, new Vector4()}
        };
    }
    
    private void SpawnTargetWithLabel(float x, float y, int appIndex, bool isGoal = false)
    {
        var pos = new Vector3(
            x,
            y,
            1f
        ) * (TargetSpacing * targetScale);
                    
        var targetObject = Instantiate(targetWithLabel, pos, Quaternion.identity, transform);
        targetObject.name = isGoal ? "Target" : "DistractorTarget";
        targetObject.transform.localScale = Vector3.one * targetScale;
        targetObject.transform.parent = mainCamera.transform;
        targetObject.tag = "Target";
         
        var label = targetObject.GetComponentInChildren<TextMeshPro>();
        label.text = appNames[appIndex];
        var targetScript = targetObject.GetComponentInChildren<Target>();
        if (isGoal)
        {
            primeTarget = targetScript;
            targetScript.SetGoalTarget();   
        }
        targetList.Add(targetScript);
    }

    private float getAmplitudeDiff(Vector3 pos, float amplitude)
    {
        return Mathf.Abs((new Vector2(0, 0) - new Vector2(pos.x, pos.y)).magnitude - amplitude);
    }
    private Tuple<List<Vector3>, Vector3> PickTarget(float amplitude, int numQuadrants = 4)
    {
        var validPositions = new List<Vector3>(targetPositions).Where(pos => (int) pos.z <= numQuadrants).ToList();
        // Sort the targets based on their closeness to the desired amplitude (distance)
        validPositions.Sort((posA, posB) =>
        {
            var diffA = getAmplitudeDiff(posA, amplitude);
            var diffB = getAmplitudeDiff(posB, amplitude);
            return diffA.CompareTo(diffB);
        });

        // For variability, select randomly from which positions match closest to the desired amplitude
        var rand = new Random();
        var closestDiff = Mathf.Abs((new Vector2(0, 0) - new Vector2(validPositions[0].x, validPositions[0].y)).magnitude - amplitude);
        var closestMatches = validPositions.Where(pos =>
        {
            var diff = getAmplitudeDiff(pos, amplitude);
            return Math.Abs(diff - closestDiff) < 0.001f;
        }).ToList(); 
        var chosenPosition = closestMatches[rand.Next(closestMatches.Count)];
        Debug.Log($"Picked position at {chosenPosition} with error {getAmplitudeDiff(chosenPosition, amplitude)}");
        SpawnTargetWithLabel(chosenPosition.x, chosenPosition.y, 0, true);
        validPositions.Remove(chosenPosition);

        // (Moved from generateTargetPositions)
        // Sort the targets based on their distance to the center of the screen (divided by aspect to allow more ovular distribution)
        validPositions.Sort((posA, posB) =>
        {
            var disA = (new Vector2(0,0) - new Vector2(posA.x/mainCamera.aspect,posA.y)).magnitude;
            var disB = (new Vector2(0,0) - new Vector2(posB.x/mainCamera.aspect,posB.y)).magnitude;
            return disB.CompareTo(disA);
        });
        return new Tuple<List<Vector3>, Vector3>(validPositions, chosenPosition);
    }

    public void SpawnStartTarget()
    {
        startTargetObject = Instantiate(targetWithLabel, worldCentre, Quaternion.identity, transform);
        startTargetObject.transform.localScale = Vector3.one * 2.0f;
        startTargetObject.tag = "Target";

        var target = startTargetObject.GetComponentInChildren<Target>();
        target.SetStartTarget();
        startTarget = target;
        targetList.Add(target);
        
        var label = startTargetObject.GetComponentInChildren<TextMeshPro>();
        label.text = "Start!";
    }

    public GameObject[] GetAllTargets()
    {
        return targetList.ConvertAll(t => t.gameObject).ToArray();
    }

    public void DestroyAllTargets()
    {
        foreach (var target in targetList)
        {
            target.DestroyGameObject();
        }
    }

    public int GetNumTotalTargets()
    {
        return this.numTargets;
    }
}

